import tkinter as tk
from tkinter import ttk, messagebox
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import math
from dataclasses import dataclass
from typing import List, Tuple
import matplotlib

matplotlib.use('TkAgg')


@dataclass
class SimulationResult:
    """Класс для хранения результатов моделирования"""
    dt: float
    trajectory: List[Tuple[float, float]]
    range: float
    max_height: float
    final_speed: float


class BallisticApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Моделирование полета тела в атмосфере")
        self.root.geometry("1400x800")

        # Параметры по умолчанию
        self.g = 9.81  # ускорение свободного падения, м/с²
        self.mass = 1.0  # масса тела, кг
        self.rho = 1.225  # плотность воздуха, кг/м³
        self.Cd = 0.47  # коэффициент лобового сопротивления (для сферы)
        self.A = 0.01  # площадь поперечного сечения, м²
        self.v0 = 100.0  # начальная скорость, м/с
        self.angle = 45.0  # угол запуска, градусы

        # Список для хранения результатов
        self.results: List[SimulationResult] = []

        # Цвета для разных траекторий
        self.colors = ['blue', 'red', 'green', 'orange', 'purple', 'brown']

        self.setup_ui()

    def setup_ui(self):
        """Настройка пользовательского интерфейса"""
        # Основные фреймы
        control_frame = ttk.Frame(self.root, padding="10")
        control_frame.grid(row=0, column=0, sticky="nw")

        plot_frame = ttk.Frame(self.root, padding="10")
        plot_frame.grid(row=0, column=1, sticky="nsew")

        table_frame = ttk.Frame(self.root, padding="10")
        table_frame.grid(row=1, column=0, columnspan=2, sticky="ew")

        # Конфигурация сетки
        self.root.grid_columnconfigure(1, weight=1)
        self.root.grid_rowconfigure(0, weight=1)

        # Панель управления
        ttk.Label(control_frame, text="ПАРАМЕТРЫ ЗАПУСКА", font=('Arial', 12, 'bold')).grid(row=0, column=0,
                                                                                            columnspan=2, pady=10)

        # Поля ввода параметров
        params = [
            ("Начальная скорость (м/с):", self.v0),
            ("Угол запуска (градусы):", self.angle),
            ("Масса тела (кг):", self.mass),
            ("Плотность воздуха (кг/м³):", self.rho),
            ("Коэффициент сопротивления:", self.Cd),
            ("Площадь сечения (м²):", self.A),
        ]

        self.entries = {}
        for i, (label, default) in enumerate(params, 1):
            ttk.Label(control_frame, text=label).grid(row=i, column=0, sticky="w", pady=5)
            entry = ttk.Entry(control_frame, width=15)
            entry.insert(0, str(default))
            entry.grid(row=i, column=1, pady=5)
            self.entries[label.split(":")[0]] = entry

        # Поле для ввода шага моделирования
        ttk.Label(control_frame, text="Шаг моделирования (с):", font=('Arial', 10, 'bold')).grid(row=7, column=0,
                                                                                                 sticky="w",
                                                                                                 pady=(20, 5))
        self.dt_entry = ttk.Entry(control_frame, width=15)
        self.dt_entry.insert(0, "0.01")
        self.dt_entry.grid(row=7, column=1, pady=(20, 5))

        # Кнопки
        buttons_frame = ttk.Frame(control_frame)
        buttons_frame.grid(row=8, column=0, columnspan=2, pady=20)

        ttk.Button(buttons_frame, text="Запустить моделирование",
                   command=self.run_simulation).pack(side=tk.LEFT, padx=5)
        ttk.Button(buttons_frame, text="Очистить результаты",
                   command=self.clear_results).pack(side=tk.LEFT, padx=5)


        # Информация о текущих параметрах
        info_frame = ttk.LabelFrame(control_frame, text="Текущие параметры", padding="10")
        info_frame.grid(row=9, column=0, columnspan=2, pady=10, sticky="ew")

        self.info_label = ttk.Label(info_frame, text="", justify=tk.LEFT)
        self.info_label.pack()

        # Область для графика
        self.figure = Figure(figsize=(10, 6), dpi=100)
        self.ax = self.figure.add_subplot(111)
        self.ax.set_xlabel('Дальность, м')
        self.ax.set_ylabel('Высота, м')
        self.ax.set_title('Траектории полета тела при разных шагах моделирования')
        self.ax.grid(True, alpha=0.3)

        self.canvas = FigureCanvasTkAgg(self.figure, plot_frame)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        # Таблица результатов
        ttk.Label(table_frame, text="РЕЗУЛЬТАТЫ МОДЕЛИРОВАНИЯ",
                  font=('Arial', 12, 'bold')).pack()

        # Создание таблицы
        columns = ("Шаг (с)", "Дальность (м)", "Макс. высота (м)",
                   "Скорость в конце (м/с)", "Время полета (с)")

        self.tree = ttk.Treeview(table_frame, columns=columns,
                                 show="headings", height=8)

        # Заголовки столбцов
        for col in columns:
            self.tree.heading(col, text=col)
            self.tree.column(col, width=150, anchor=tk.CENTER)

        # Scrollbar для таблицы
        scrollbar = ttk.Scrollbar(table_frame, orient=tk.VERTICAL,
                                  command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)

        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Обновление информации
        self.update_info()

    def get_parameters(self):
        """Получение параметров из полей ввода"""
        try:
            params = {
                'v0': float(self.entries['Начальная скорость (м/с)'].get()),
                'angle': float(self.entries['Угол запуска (градусы)'].get()),
                'mass': float(self.entries['Масса тела (кг)'].get()),
                'rho': float(self.entries['Плотность воздуха (кг/м³)'].get()),
                'Cd': float(self.entries['Коэффициент сопротивления'].get()),
                'A': float(self.entries['Площадь сечения (м²)'].get()),
                'dt': float(self.dt_entry.get())
            }

            if params['dt'] <= 0:
                raise ValueError("Шаг моделирования должен быть положительным")
            if params['v0'] <= 0:
                raise ValueError("Начальная скорость должна быть положительной")
            if params['angle'] <= 0 or params['angle'] >= 90:
                raise ValueError("Угол должен быть в пределах 0-90 градусов")

            return params
        except ValueError as e:
            messagebox.showerror("Ошибка ввода", f"Некорректные данные: {str(e)}")
            return None

    def calculate_drag_force(self, v, params):
        """Расчет силы сопротивления воздуха"""
        return 0.5 * params['rho'] * params['Cd'] * params['A'] * v ** 2

    def run_simulation(self):
        """Запуск моделирования полета"""
        params = self.get_parameters()
        if params is None:
            return

        dt = params['dt']

        # Проверка на дублирование шага
        for result in self.results:
            if abs(result.dt - dt) < 1e-10:
                if not messagebox.askyesno("Подтверждение",
                                           f"Моделирование с шагом {dt} с уже выполнено. Повторить?"):
                    return

        # Преобразование угла в радианы
        angle_rad = math.radians(params['angle'])

        # Начальные условия
        x, y = 0.0, 0.0
        vx = params['v0'] * math.cos(angle_rad)
        vy = params['v0'] * math.sin(angle_rad)

        # Списки для хранения траектории
        trajectory = [(x, y)]
        times = [0.0]

        # Моделирование полета (метод Эйлера)
        t = 0.0
        max_height = 0.0


        while y >= 0:
            # Расчет скорости
            v = math.sqrt(vx ** 2 + vy ** 2)

            # Расчет сил
            drag_force = self.calculate_drag_force(v, params)

            # Ускорения с учетом сопротивления воздуха
            ax = -drag_force * vx / (params['mass'] * v) if v > 0 else 0
            ay = -self.g - drag_force * vy / (params['mass'] * v) if v > 0 else -self.g

            # Интегрирование методом Эйлера
            vx += ax * dt
            vy += ay * dt
            x += vx * dt
            y += vy * dt
            t += dt

            # Сохранение траектории
            trajectory.append((x, y))
            times.append(t)

            # Обновление максимальной высоты
            if y > max_height:
                max_height = y

        # Расчет результатов
        range_distance = x  # Дальность полета
        final_speed = math.sqrt(vx ** 2 + vy ** 2) if y <= 0 else 0
        flight_time = t

        # Создание объекта результата
        result = SimulationResult(
            dt=dt,
            trajectory=trajectory,
            range=range_distance,
            max_height=max_height,
            final_speed=final_speed
        )

        # Добавление в список результатов
        self.results.append(result)

        # Обновление интерфейса
        self.update_plot()
        self.update_table()
        self.update_info()

    def update_plot(self):
        """Обновление графика траекторий"""
        self.ax.clear()

        # Отрисовка всех траекторий
        for i, result in enumerate(self.results):
            color = self.colors[i % len(self.colors)]
            x_vals = [p[0] for p in result.trajectory]
            y_vals = [p[1] for p in result.trajectory]

            self.ax.plot(x_vals, y_vals,
                         label=f'Δt = {result.dt:.4f} с',
                         color=color, linewidth=2)

            # Отметка конечной точки
            self.ax.plot(x_vals[-1], y_vals[-1], 'o',
                         color=color, markersize=8)

        self.ax.set_xlabel('Дальность, м')
        self.ax.set_ylabel('Высота, м')
        self.ax.set_title('Траектории полета тела при разных шагах моделирования')
        self.ax.grid(True, alpha=0.3)
        self.ax.legend(loc='upper right')
        self.ax.set_xlim(left=0)
        self.ax.set_ylim(bottom=0)

        self.canvas.draw()

    def update_table(self):
        """Обновление таблицы результатов"""
        # Очистка таблицы
        for item in self.tree.get_children():
            self.tree.delete(item)

        # Заполнение новыми данными
        for result in self.results:
            # Расчет времени полета
            flight_time = len(result.trajectory) * result.dt

            self.tree.insert("", tk.END, values=(
                f"{result.dt:.6f}",
                f"{result.range:.2f}",
                f"{result.max_height:.2f}",
                f"{result.final_speed:.2f}",
                f"{flight_time:.2f}"
            ))

    def update_info(self):
        """Обновление информации о параметрах"""
        if self.results:
            last_result = self.results[-1]
            info_text = f"Последнее моделирование:\n"
            info_text += f"Шаг: {last_result.dt:.6f} с\n"
            info_text += f"Дальность: {last_result.range:.2f} м\n"
            info_text += f"Макс. высота: {last_result.max_height:.2f} м\n"
            info_text += f"Скорость в конце: {last_result.final_speed:.2f} м/с"
        else:
            info_text = "Моделирование не проводилось"

        self.info_label.config(text=info_text)

    def clear_results(self):
        """Очистка всех результатов"""
        if messagebox.askyesno("Подтверждение",
                               "Очистить все результаты моделирования?"):
            self.results.clear()
            self.update_plot()
            self.update_table()
            self.update_info()


    

def main():
    """Основная функция приложения"""
    root = tk.Tk()
    app = BallisticApp(root)

    # Пример автоматического запуска нескольких симуляций
    def run_example_simulations():
        # Запуск с разными шагами
        steps = [1, 0.1, 0.01, 0.001, 0.0001]

        for step in steps:
            app.dt_entry.delete(0, tk.END)
            app.dt_entry.insert(0, str(step))
            app.run_simulation()
            root.update()

    # Запуск примера через 1 секунду
    root.after(1000, run_example_simulations)

    root.mainloop()


if __name__ == "__main__":
    main()
